<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Exploit Development on Cybernetic Coffee</title>
    <link>https://cybernetic.coffee/tags/exploit-development/</link>
    <description>Recent content in Exploit Development on Cybernetic Coffee</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 23 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://cybernetic.coffee/tags/exploit-development/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Learn Source Code Auditing By Building a Tool #2: POC and Pattern Analysis for Basic Vulnerabilities</title>
      <link>https://cybernetic.coffee/blog/learn-source-code-auditing_2/</link>
      <pubDate>Thu, 23 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cybernetic.coffee/blog/learn-source-code-auditing_2/</guid>
      <description>I already rambled about what source code auditing is, why we do it, and its pros vs cons over dynamic analysis. So in this post I&amp;rsquo;ll present some basic vulnerabilities we can look for in audits and how we might build a tool for their detection using simple pattern matching and rules.
Key Terms Signature: An encapsulating term to refer to both a set of rules and a description of what the rule aims to detect and why the matching of such a rule could indicate the presence of a vulnerability Rule: A regex pattern with a specific detection goal under a particular signature Regex: Regular expressions are a way of specifying a search pattern particular for natural languages What are we Building?</description>
    </item>
    
    <item>
      <title>Learn Source Code Auditing By Building a Tool #1: Static Analysis for the Dynamically Paralysed</title>
      <link>https://cybernetic.coffee/blog/learn-source-auditing-1/</link>
      <pubDate>Mon, 06 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cybernetic.coffee/blog/learn-source-auditing-1/</guid>
      <description>Source code auditing/analysis is like taking the blueprint for a car and trying to find flaws in the design before it is ever built and sold to the public. This has advantages over just testing the car once it has been manufactured but is not without flaws. It&amp;rsquo;s much easier to miss things when presented with a massively complex system whose operations may only be visualized or imagined. Of course it is also possible to have both a fully constructed model and a blueprint with which to audit the car for flaws.</description>
    </item>
    
    <item>
      <title>Forgotten pwntools</title>
      <link>https://cybernetic.coffee/blog/forgotten-pwntools/</link>
      <pubDate>Tue, 24 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cybernetic.coffee/blog/forgotten-pwntools/</guid>
      <description>You&amp;rsquo;d think after searching for /bin/sh in libc that many times in pwntools that I&amp;rsquo;d remember the syntax. But actually my brain is too busy remembering when the milk in the fridge expires. Here&amp;rsquo;s a collection of my favorite forgotten syntactic gems for pwntools.
General flat payload = flat({ # pad with garbage to this offset cyclic_find(&amp;#39;amia&amp;#39;): rop.chain() }) custom filler
alphabet = &amp;#39;bcdefhijklmnopqrstuvwyz&amp;#39; # cleansed alphabet payload = fit({ cyclic_find(&amp;#39;nbbb&amp;#39;, alphabet=bet): rop.</description>
    </item>
    
    <item>
      <title>Reversing 31 Binaries for No Fun and Regret</title>
      <link>https://cybernetic.coffee/blog/reversing-34-binaries/</link>
      <pubDate>Sun, 15 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cybernetic.coffee/blog/reversing-34-binaries/</guid>
      <description>&amp;ldquo;If you know the enemy and know yourself, you need not fear the result disassembly of a hundred battles 31 binaries.&amp;rdquo;
&amp;ndash; Sun Tzu, The Art of War Exploitation
Overview So you want to hack a program? Go to nsogroup.com &amp;hellip;
Reverse engineering, or &amp;lsquo;reversing&amp;rsquo;, is the process of taking something whose inner workings are not immediately clear or incredibly complex and making sense of them. Thus we see that reversing is not just a skill for security engineers but for all engineers, programmers and problem solvers.</description>
    </item>
    
    <item>
      <title>ROP Emporium Revisited</title>
      <link>https://cybernetic.coffee/blog/rop-emporium-revisited/</link>
      <pubDate>Tue, 27 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cybernetic.coffee/blog/rop-emporium-revisited/</guid>
      <description>Overview ROP highlights a classical strategy across all facets of security exploitation, living off the land.
ret2win #2 ret2win is the first challenge among the rop emporium suite and plays out like a classical buffer overflow. The only real takeaway from this challenge is to note the state of the memory protections enabled for the binary.
Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) We see that the NX bit is enabled this is true of almost all ROP challenges since we wish to prevent execution off the stack with shellcode.</description>
    </item>
    
    <item>
      <title>Basic Stack Based Overflows</title>
      <link>https://cybernetic.coffee/blog/basic-stack-based-overflows/</link>
      <pubDate>Thu, 01 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://cybernetic.coffee/blog/basic-stack-based-overflows/</guid>
      <description>Overview Stack based buffer overflows are old as fuck. Like I was literally dead when the most advanced techniques for exploiting them were conceived. However pwntools is a exploitation framework that has been around for a much shorter period of time and adds a new level of simplicity which makes exploit development more approachable. Of course there exist a great number of better binary exploitation courses and guides, a few of which I will link in the resources section bellow.</description>
    </item>
    
    <item>
      <title>Hello Kernel</title>
      <link>https://cybernetic.coffee/blog/hello-kernel/</link>
      <pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://cybernetic.coffee/blog/hello-kernel/</guid>
      <description>How can we integrate our rootkit into the kernel? How does the Linux kernel work regarding drivers? What does driver code look like? Where can we debug a Linux driver at runtime?
This week looks at what it takes to get a rootkit running on the ubuntu (and forked distros) Linux kernel and highlights the way in which rootkits are engineered for specific operating system kernels. Initially we investigate entry points in the ‘kernel land’ and why drivers help us handle the monolithic kernel.</description>
    </item>
    
    <item>
      <title>Kernel Mode Rootkits</title>
      <link>https://cybernetic.coffee/blog/kernel-mode-rootkits/</link>
      <pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://cybernetic.coffee/blog/kernel-mode-rootkits/</guid>
      <description>What is a kernel mode rootkit? How is a kernel mode rootkit developed?
This week looks at the second alternative &amp;rsquo;type&amp;rsquo; of rootkit that could be constructed over the course of the project. This post also provides reasoning for which combination of decision points have been chosen and details a development plan going forward.
Kernel Mode Rootkits Unlike ‘user mode’ rootkits, which were discussed last week, kernel mode rootkits execute directly at kernel level privilege.</description>
    </item>
    
    <item>
      <title>Radical Rootkit Research</title>
      <link>https://cybernetic.coffee/blog/radical-rootkit-research/</link>
      <pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://cybernetic.coffee/blog/radical-rootkit-research/</guid>
      <description>This series of blog posts covers some research I did into rootkits with a focus on Linux kernel based rootkits via malicious drivers. Over the series I implement a rudimentary poc, source here
Note at the time of writing the rootkit I had previously never written C and undertook this project as a means to learn it. If you like that idea you should checkout Creating a Rootkit to Learn C which I only found after I finished this little project.</description>
    </item>
    
  </channel>
</rss>
