<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>security research on Cybernetic Coffee</title>
    <link>https://cybernetic.coffee/categories/security-research/</link>
    <description>Recent content in security research on Cybernetic Coffee</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 28 Mar 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://cybernetic.coffee/categories/security-research/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>The Art of Syscall Hooking</title>
      <link>https://cybernetic.coffee/blog/the-art-of-hooking/</link>
      <pubDate>Sat, 28 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://cybernetic.coffee/blog/the-art-of-hooking/</guid>
      <description>How can we have our rootkit avoid detection from prying eyes? What kinds of things do we want to hide from?
This time we get into the meat and bones of our rootkit and look at hooking system calls (sys calls) to help us remain hidden from the wandering eyes of system administrators.
Syscall Hooking Note there are other types of hooking, I.E inline hooking (most windows rootkits)
Hooking is not a new concept and forms a part of normal operation in the Linux kernel.</description>
    </item>
    
    <item>
      <title>Hello Kernel</title>
      <link>https://cybernetic.coffee/blog/hello-kernel/</link>
      <pubDate>Wed, 18 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://cybernetic.coffee/blog/hello-kernel/</guid>
      <description>How can we integrate our rootkit into the kernel? How does the Linux kernel work regarding drivers? What does driver code look like? Where can we debug a Linux driver at runtime?
This week looks at what it takes to get a rootkit running on the ubuntu (and forked distros) Linux kernel and highlights the way in which rootkits are engineered for specific operating system kernels. Initially we investigate entry points in the ‘kernel land’ and why drivers help us handle the monolithic kernel.</description>
    </item>
    
    <item>
      <title>Kernel Mode Rootkits</title>
      <link>https://cybernetic.coffee/blog/kernel-mode-rootkits/</link>
      <pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://cybernetic.coffee/blog/kernel-mode-rootkits/</guid>
      <description>What is a kernel mode rootkit? How is a kernel mode rootkit developed?
This week looks at the second alternative &amp;rsquo;type&amp;rsquo; of rootkit that could be constructed over the course of the project. This post also provides reasoning for which combination of decision points have been chosen and details a development plan going forward.
Kernel Mode Rootkits Unlike ‘user mode’ rootkits, which were discussed last week, kernel mode rootkits execute directly at kernel level privilege.</description>
    </item>
    
    <item>
      <title>Radical Rootkit Research</title>
      <link>https://cybernetic.coffee/blog/radical-rootkit-research/</link>
      <pubDate>Wed, 04 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://cybernetic.coffee/blog/radical-rootkit-research/</guid>
      <description>This series of blog posts covers some research I did into rootkits with a focus on Linux kernel based rootkits via malicious drivers. Over the series I implement a rudimentary poc, source here
Note at the time of writing the rootkit I had previously never written C and undertook this project as a means to learn it. If you like that idea you should checkout Creating a Rootkit to Learn C which I only found after I finished this little project.</description>
    </item>
    
  </channel>
</rss>
